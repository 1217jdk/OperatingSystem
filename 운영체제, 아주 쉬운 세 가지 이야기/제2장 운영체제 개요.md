# 프로그램이 실행될 때 어떤 일이 일어날까?

- 프로그램이 하는 일은 `명령어를 실행`하는 것
- 명령어를 실행할 때 크게 `3가지` 동작을 수행
  - `반입(fetch)`: 명령어를 `메모리에 적재`하는 것
  - `해석(decode)`: 어떤 명령어인지 `해석`하는 것
  - `실행(execute)`: 명령어가 지정한 `동작을 수행`하는 것

# 운영체제(Operating System, OS)란?

- 시스템을 편하게 사용하기 위해 프로그램이 실행될 때 일어나는 다양한 동작들을 수행해주는 소프트웨어
- 시스템을 항상 정확하고 올바르게 동작시킬 책임이 있음
- 운영체제는 이를 위해 `가상화(virtualization)`, `병행성(concurrency)`, `영속성(persistence)`이라는 개념을 사용함

# 가상화

- 프로세서, 메모리, 디스크 등의 `물리적 자원`으로 `가상 자원`을 `생성`하는 것
- 운영체제를 `가상 머신(virtual machine)`이라고도 부름
- 사용자가 운영체제에게 가상화와 관련된 요청을 할 수 있도록 `API`가 제공됨
  - 보통 응용 프로그램이 사용 가능한 수백 개의 `시스템 콜`이 제공됨
  - 이를 `표준 라이브러리(standard library)`가 제공된다고 표현하기도 함
- 운영체제에서 가장 중요한 것을 `어떻게 자원을 가상화시키는가` 이다.  
  즉, 다음과 같은 질문들에 답을 할 수 있어야 한다.
  - 가상화를 위해 운영체제가 구현하는 기법과 정책은 무엇인가?
  - 기법과 정책들을 어떻게 효율적으로 구현하고 있는가?
  - 효율적인 구현을 위해 어떤 하드웨어 지원이 필요한가?
- 가상화 기법은 많은 프로그램들이 자원을 공유하면서 실행되도록 함
  - 운영체제가 이를 관리하는 자원 관리자의 역할도 수행

## CPU 가상화

- 하나의 CPU 또는 소규모의 CPU 집합을 무한개의 CPU가 존재하는 것처럼 변환하여 동시에 많은 수의 프로그램을 실행시키는 것을 `CPU 가상화`라 부름

```
int main(int argc, char *argv[]) {
  if (argc != 2) {
    fprintf(stderr, "usage: cpu <string>\n");
    exit(1);
  }
  char *str = argv[1];
  while (1) {
    Spin(1);
    printf("%s\n", str);
  }
  return 0;
}
```

- 이 코드는 Spin()을 1초 동안 호출한 후 리턴하고, 사용자가 전달한 문자를 출력하는 것을 무한히 반복한다.
- 이 코드를 저장하고 단일 프로세서(CPU)에서 컴파일하고 실행시킬 수 있다.  
  ex) cpu.c로 코드를 저장한 뒤 프로그램 실행

  ```
  # cpu.c 코드 컴파일
  prompt> gcc -o cpu cpu.c -Wall

  # 컴파일된 코드 실행
  prompt> ./cpu "A"
  ```

  - 여러 인스턴스를 동시에 실행시킬 수도 있음
    ```
    prompt> ./cpu A & ; ./cpu B & ; ./cpu C & ; ./cpu D &
    ```
    - 단일 프로세서 환경이지만 마치 여러 개의 가상 CPU가 존재하는 것처럼 동작

## 메모리 가상화

```
int main(int argc, char *argv[]) {
  int *p = malloc(sizeof(int)); // a1
  assert(p != NULL);
  printf("(%d) memory address of p: %08x\n)", getpid(), (unsigned) p); // a2
  *p = 0; // a3
  while (1) {
    Spin(1);
    *p = *p + 1;
    printf("(%d) p: %d\n", getpid(), *p); // a4
  }
  return 0;
}
```

- 이 코드는 다음과 같은 작업을 수행
  - a1: 메모리를 할당
  - a2: 할당받은 메모리 주소를 출력
  - a3: 할당받은 메모리의 첫 슬롯에 0을 넣음
  - a4: 1초 대기 후, 변수 p가 가리키는 주소에 저장되어 있는 값을 1 증가시키고 값을 출력. 무한 반복
- 이 코드를 mem.c로 작성하고 컴파일 및 실행하면 다음과 같은 결과를 볼 수 있음
  ```
  prompt> ./mem &; ./mem &
  [1] 24113
  [2] 24114
  (24113) memory address of p: 00200000
  (24114) memory address of p: 00200000
  (24113) p: 1
  (24114) p: 1
  (24114) p: 2
  (24113) p: 2
  (24113) p: 3
  (24114) p: 3
  (24113) p: 4
  (24114) p: 4
  ...
  ```
  - 두 프로세스는 p의 주소로 동일한 곳을 가리키고 있지만, 실제 동작은 서로 다른 메모리를 참조하는 것처럼 보임
- 운영체제는 각 프로세스가 자신만의 가상 주소 공간을 가지도록 만들 수 있음
  - 실제로는 각 가상 주소 공간이 물리 메모리에 매핑되어 있음
- 운영체제의 위와 같은 기능을 `메모리 가상화`라 함

# 병행성

- 프로그램이 동시에 많은 일을 처리할 때 병행성 문제가 발생할 수 있음
  - 이런 문제는 운영체제 자체 또는 멀티 쓰레드 환경에서 발생할 수 있음

```
volatile int counter = 0;
int loops;
void *worker(void *arg) {
  int i;
  for (i = 0; i < loops; i++) {
    counter++;
  }
  return NULL;
}
```

- 이 함수는 loops에 설정된 값 만큼 반복을 돌면서 counter 값을 증가시킴
- 이 함수를 2개의 쓰레드에서 수행하면 loops에 설정된 값의 2배가 출력됨
  - loops의 값이 작을 때는 예상대로 loops가 N일 때 2N이 출력됨
  - 그러나 loops의 값이 커지면 2N이 출력되지 않을 수 있음
- counter를 증가시키는 부분은 크게 3개의 명령어로 이루어짐
  - counter의 값을 메모리에서 레지스터로 탑재
  - 레지스터의 값을 1 증가시킴
  - 레지스터의 값을 다시 메모리에 저장
- 위와 같은 3개의 명령어가 원자적(atomically)으로 실행되지 않기 때문에 문제가 발생하는 것
- 같은 메모리 공간에 다수의 쓰레드가 동시에 실행된다고 할 때 다음과 같은 고민을 해볼 필요가 있음
  - 운영체제로부터 어떤 기본 기법들을 제공받아야 하는가?
  - 하드웨어는 어떤 기능을 제공해야 하는가?
  - 병행성 문제를 해결하기 위해 기본 기법들과 하드웨어 기능을 어떻게 이용할 수 있는가?

# 영속성

- DRAM과 같은 장치는 데이터를 휘발성(volatile) 방식으로 저장하므로 쉽게 손실될 수 있음  
  -> 데이터를 영속적으로 저장할 수 있는 하드웨어와 소프트웨어가 필요함
- 데이터를 영속적으로 저장하기 윈한 장치로 보통 하드 디스크를 사용
- 디스크를 관리하는 운영체제 소프트웨어를 파일 시스템이라 함
- 데이터를 디스크에 쓰기 위해서 운영체제는 많은 동작들을 함
  - 디스크 탐색을 통해 데이터를 저장할 곳을 결정
  - 다양한 자료구조를 바탕으로 데이터의 상태를 추적
  - 위와 같은 작업들을 위해 기존 자료구조를 읽거나 갱신
- 데이터를 영속적으로 보관하기 위해서는 저수준의 인터페이스와 그 시맨틱에 대한 깊은 이해가 필요
  - 운영체제는 시스템 콜이라는 표준화된 방법으로 장치들을 접근할 수 있게 도와줌
- 장치에 접근해서 쓰기 등의 작업을 할 때 갑작스런 고장에 대비해 저널링이나 CoW(Copy on Write)와 같은 기법이 사용되기도 함
- 효율적인 디스크 작업을 위해서 B-트리 등의 다양한 자료구조도 사용됨

# 설계 목표

- 운영체제가 실제로 하는 일들은 정리하자면 물리 자원을 가상화하고, 병행성과 관련된 문제를 해결하고, 파일을 영속적으로 저장하는 것이라고 할 수 있음
- 이런 운영체제를 만들기 위해서는 다음과 같은 목표를 설계할 필요가 있음
  - 기본적인 목표는 시스템을 편리하고 사용하기 쉽도록 개념들을 정의
  - 가장 중요한 목표는 성능, 즉 오버헤드를 최소화 하는 것
  - 응용프로그램끼리 혹은 운영체제와 응용프로그램 사이의 보호
    - 즉, 어떤 악의적인 응용프로그램이 운영체제나 다른 응용프로그램에 영향을 끼치지 않길 바라는 것
    - 다르게 말하면 높은 수준의 신뢰성을 제공해야 한다고 할 수 있음
  - 이 외에도 에너지-효율성, 이동성 등이 있음

# 역사

## 초창기 운영체제: 단순 라이브러리

- 초창기 운영체제는 자주 사용하는 함수들을 모아둔 라이브러리에 가까웠음
- 현대의 운영체제가하는 일들을 컴퓨터 관리자가 직접함
- 보통 작업들을 모아두고 한번에 처리했는데 이런 방식의 작업을 일괄 처리(batch)라 부름

## 라이브러리를 넘어서: 보호

- 운영체제가 실행하는 코드 이외에는 디스크를 함부로 읽어선 안됨
- 사용자 응용 프로그램은 사용자 모드로 실행되기 때문에 할 수 있는 일이 하드웨어적으로 제한됨
- 시스템 콜은 trap이라는 하드웨어 명령어를 이용하여 호출됨
- 시스템 콜이 시작되면 하드웨어는 trap handler 함수에게 제어권을 넘기고 특권 수준을 커널 모드로 격상시킴
  - trap handler 함수는 운영체제가 미리 구현해 둠
  - 커널 모드에서는 운영체제가 하드웨어를 자유롭게 접근할 수 있음
- 운영체제가 서비스를 완료하면 return-from-trap이라는 명령어로 응용 프로그램의 출발점으로 제어권을 넘기고 사용자 모드로 전환

## 멀티프로그래밍 시대

- 운영체제 다운 운영체제는 미니컴퓨터 시대에 이루어짐
- PDP 계열 컴퓨터가 등장하면서 컴퓨터의 가격이 크게 낮아짐
  - 각 기관에서도 큰 컴퓨터를 하나 갖는 대신 각 그룹마다 컴퓨터를 가질 수 있게됨
  - 개발자들의 활동이 활발해지고 더 많은 인력이 컴퓨터 분야로 몰려듦
  - 컴퓨터 시스템의 개발이 왕성하게 이루어짐
- 자원을 효율적으로 활용하기 위한 멀티프로그래밍 기법이 대중적으로 사용되기 시작
  - 한 번에 하나의 프로그램만 실행하는 대신 여러 작업을 메모리에 올려두고 번갈아 가면서 작업할 수 있게 됨
  - 아직 입출력 장치가 느리기 때문에 전환 능력이 특히 중요하게 다뤄짐
- 멀티프로그래밍에 보급에 따라 메모리 보호나 병행성과 같은 문제가 중요해짐
- 유닉스의 등장

## 현대

- 현재의 개인용 컴퓨터(PC, Personal Computer)의 등장
- 그러나 PC의 등장 초기에는 오히려 운영체제의 기능이 퇴보함
  - DOS(Disk Operating System)이라는 초기 운영체제는 메모리 보호를 신경쓰지 않음
  - 1세대 Mac OS는 작업 스케줄링에 협업 스케줄링을 채용해서 쓰레드가 무한 루프에 빠지면 전체 시스템이 정지되는 문제가 있었음
- 암흑기를 극복한 뒤에는 다양한 운영체제 기법을 접목시키기 시작했고, 운영체제 기술을 크게 발전시킴

# 요약

- 앞서 소개한 많은 내용들을 앞으로 다양한 챕터를 통해 다룰 예정
- 이 외에도 이 책에서는 다루지 않는 네트워킹 코드, 그래픽 장치, 보안 등 많은 개념들이 운영체제에 존재
