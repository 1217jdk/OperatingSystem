# 개요

- 멀티프로세서 스케줄링은 병행성에 관한 내용을 먼저 학습한 후 다루는 것이 좋기 때문에 여기서는 간단하게만 다룰 것
- 단일 CPU의 성능 한계를 느끼고 멀티코어 기술을 적용
- 기존에 작성된 프로그램들은 단일 CPU만을 사용하도록 작성됐기 때문에 이를 멀티코어 환경에 맞게 변경해야 함

# 멀티 프로세서 구조

- CPU에는 하드웨어 캐시 계층이 존재함
- 캐시는 지역성(locality)에 기반해서 동작
- 단일 CPU 환경에서는 캐시값이 항상 최신 상태이므로 문제가 발생하지 않음
- 여러 개의 CPU를 사용할 경우에는 각 CPU마다 캐시가 존재하므로 A CPU에서 수정한 값이 B CPU에 적용되지 않을 수 있음
  - 메모리에 데이터를 쓰는 것은 시간이 오래 걸리기 때문에 A CPU에서 수정된 값은 메모리에 바로 적용되지 않고 캐시에서만 우선 수정
  - B CPU에서는 변경되기 전의 값을 메모리에서 읽기 때문에 동기화 문제가 발생
- 기본적인 해결 방법은 하드웨어 수준에서 캐시가 연결된 메모리를 항상 감시하는 것이 있음
  - 버스 기반 시스템에서는 버스 스누핑(bus snooping)이라는 기법을 사용
    - 캐시가 자신과 메모리를 연결하는 버스의 통신 상황을 계속해서 모니터링 하고, 변경이 발생했을 때 캐시를 삭제하거나 갱신하는 방식

# 동기화

- 캐시와 메모리의 일관성이 보장되더라도 상호 배제가 보장되지 않는다면 문제가 발생할 수 있음
  - ex) CPU A, B에서 동시에 같은 메모리에 대한 쓰기 작업을 수행
- 이를 해결하기 위해 락(lock) 같은 동기화 기법을 사용
- 자세한 사항은 병행성의 교착 상태 장에서 다룰 것

# 캐시 친화성

- 캐시는 CPU에 존재하기 때문에 어떤 프로세스를 다시 실행할 때 이전과 다른 CPU를 사용하면 캐시의 효과를 볼 수 없음
- 가능한 한 프로세스를 이전과 동일한 CPU에서 실행하는 것이 좋음

# 단일 큐 멀티프로세스 스케줄링

- CPU에서 처리할 작업을 큐에 넣어두고 순서대로 각 CPU에 배정하는 방식
- 멀티프로세스 스케줄링을 구현하는 가장 단순한 방법
- 단, 구현이 단순한만큼 단점이 존재
  - 확장성이 결여됨
    - 각 CPU에서 단일 큐에 대해 작업을 pop을 하는 동작에 단일 락이 사용되기 때문에 CPU의 수가 늘어날 수록 성능이 저하될 수 있음
  - 순서대로 CPU에 할당되기 때문에 캐시 친화성을 보장할 수 없음
    - 캐시 친화성을 고려해서 프로세스가 배정되도록 구현할 수도 있지만, 구현이 복잡해질 수 있음

# 멀티 큐 스케줄링

- 각 CPU마다 큐를 두는 방식
- 시스템에 작업이 들어왔을 때 적절한 큐에 작업을 할당
  - 작업 할당에는 랜덤, 라운드 로빈 등 다양한 기법이 사용될 수 있음
- 각 작업이 별개의 큐에 존재하기 때문에 단일 큐를 사용할 때 생겼던 문제들이 개선됨
  - 단일 큐에서 lock을 적용시켜 작업이 할당되던 동작이 사라졌기 때문에 확정성이 좋음
  - 항상 같은 CPU에서 작업이 수행되므로 캐시 친화성이 보장됨
- 그러나 기본적으로 어떤 큐에 작업이 할당되면 그 CPU에서 벗어나지 않기 때문에 워크로드 불균형(load imbalance) 문제가 생길 수 있음
  - 작업 a가 CPU A에, 작업 b, c가 CPU B에 할당될 경우 a는 cpu를 혼자 독점하고, b와 c는 cpu를 50%씩 사용
  - 빨리 끝나는 작업인 a, b가 CPU A에, 오래 걸리는 작업인 c, d가 CPU B에 할당될 경우 CPU B가 동작하는 동안 CPU A는 아무 작업도 처리하지 않음
- 이주(migration)라는 기법을 사용해서 위 문제를 해소할 수 있음
  - 이름처럼 어떤 CPU에서 처리하던 작업을 다른 CPU로 이주시키는 방식을 말함
  - 이주 기법에는 다양한 방식이 존재하고, 그 중 하나로 작업 훔치기(work stealing)라는 방식이 있음
    - 작업이 적은 큐에서 작업이 많은 큐를 찾아서 작업을 가져오는 방식
    - 단, 큐를 너무 자주 검사하게 되면 오버헤드가 커지기 때문에 확장성이 안좋아짐

# Linux 멀티프로세서 스케줄링

- Linux에는 멀티프로세스 스케줄링을 위한 방식이 아직 단일화되지 않음
- Linux 커뮤니티에서 다음과 같은 방식들이 제안됨

  - O(1) 스케줄러
  - CFS(Completely Fair Scheduler) 스케줄러
  - BFS 스케줄러

  # 요약

  - 단일 CPU에서 멀티 코어 환경으로 넘어가면서 멀티프로세서 스케줄링의 필요성이 부각돰
  - 단일 큐 방식은 구현이 단순하지만 확정성의 결여와 캐시 친화성이 보장되지 않는다는 문제점이 있음
  - 멀티 큐 방식은 확장성이 좋고 캐시 친화성이 보장되지만 워크로드 불균형 문제를 가지고 있고 구현이 복잡함
