# 워크로드에 대한 가정

- 일련의 프로세스들을 실행하는 상황을 워크로드(workload)라 함
- 우선 다소 이상적인 방향으로 가정을 설정하고, 점점 가정을 완화하면서 정책을 정교화 할 것
- 우선 워크로드에 대해 다음과 같은 가정을 하고 진행
  1. 모든 작업은 같은 시간 동안 실행
  2. 모든 작업은 동시에 도착
  3. 각 작업은 시작되면 완료될 때까지 실행
  4. 모든 작업은 CPU만 사용(즉, 입출력을 수행하지 않음)
  5. 각 작업의 실행 시간은 사전에 알려져 있음

# 스케줄링 평가 항목

- 각 정책을 비교하기 위한 스케줄링 평가 항목을 결정해야 함
- 문제를 간단히 하기 위해 반환 시간(turnaround time)이라는 단일 평가 항목을 사용
  - 작업 반환 시간은 작업이 완료된 시간과 작업이 시스템에 도착한 시간의 차이로 정의됨
- 반환 시간은 성능 측면의 평가 사항이고 성능 외의 평가 사항으로 공정성이 있음
- 실제로는 두 평가 사항의 균형을 잘 맞추는 것이 중요

# 스케줄링 알고리즘

## 선입선출(First In First Out, FIFO)

- 가장 기초적인 알고리즘
- 선도착선처리(First Come First Served, FCFS)라고도 함
- 작업이 도착하는 순서대로 처리를 완료하고 반환하는 방식
  ```
  예시: 작업 시간이 10초로 동일한 A, B, C가 동시에 도착하는데, 간발의 차로 A, B, C 순서대로 도착
  - A는 0초에 도착, 10초에 작업 완료 -> 반환 시간은 10 - 0 = 10
  - B는 0초에 도착, 20초에 작업 완료 -> 반환 시간은 20 - 0 = 20
  - C는 0초에 도착, 30초에 작업 완료 -> 반환 시간은 30 - 0 = 30
  => 세 작업의 평균 반환 시간은 (10 + 20 + 30) / 3 = 20
  ```
- 가장 단순하고 구현하기 쉽다는 장점이 있음
- 그러나 각 작업의 실행 시간이 다를 경우 문제가 발생
  ```
  예시: 작업 시간이 100초인 A와 작업 시간이 10초인 B, C 작업이 동시에 도착하는데, 간발의 차로 A, B, C 순서대로 도착
  - A는 0초에 도착, 100초에 작업 완료 -> 반환 시간은 10 - 0 = 10
  - B는 0초에 도착, 110초에 작업 완료 -> 반환 시간은 110 - 0 = 110
  - C는 0초에 도착, 120초에 작업 완료 -> 반환 시간은 120 - 0 = 120
  => 세 작업의 평균 반환 시간은 (100 + 110 + 120) / 3 = 110
  ```
  - 이처럼 짧은 시간 동안 자원을 사용할 프로세스들이 자원을 오랫동안 사용하는 프로세스의 종료를 기다리는 현상이 발생
  - 이런 문제를 convoy effect라 함

## 최단 작업 우선(Shortest Job First, SJF)

- 가장 짧은 실행 시간을 가진 작업을 먼저 실행시키는 방식
  ```
  예시: 작업 시간이 100초인 A와 작업 시간이 10초인 B, C가 동시에 도착
  - B는 0초에 도착, 10초에 작업 완료 -> 반환 시간은 10 - 0 = 10
  - C는 0초에 도착, 20초에 작업 완료 -> 반환 시간은 20 - 0 = 20
  - A는 0초에 도착, 120초에 작업 완료 -> 반환 시간은 120 - 0 = 120
  => 세 작업의 평균 반환 시간은 (120 + 10 + 20) / 3 = 50
  ```
- 모든 작업이 동시에 도착할 때 최적의 알고리즘
- 그러나 모든 작업이 동시에 도착하지 않으면 문제가 발생
  ```
  예시: 작업 시간이 100초인 A가 0초에 도착하고 작업 시간이 10초인 B, C가 10초에 도착
  - A는 0초에 도착, 100초에 작업 완료 -> 반환 시간은 100 - 0 = 100
  - B는 10초에 도착, 110초에 작업 완료 -> 반환 시간은 110 - 10 = 100
  - C는 10초에 도착, 120초에 작업 완료 -> 반환 시간은 120 - 10 = 110
  => 세 작업의 평균 반환 시간은 (100 + 100 + 110) / 3 = 103.333...
  ```
  - FIFO에서 발생했던 convoy effect가 다시 발생

## 최소 잔여시간 우선(Shortest Time-toCompletion First, STCF)

- SJF 방식을 유지하되 경우에 따라 자원을 선점할 수 있는 기능을 추가한 방식
- 선점형 최단 작업 우선(PSJF)라고도 함
- 이를 위해선 작업이 끝날 때까지 계속 실행된다는 가정을 완화해야 함
- 새로운 작업이 들어왔을 때, 남아있는 작업과 새로운 작업의 잔여 실행 시간 중 가장 적은 잔여 실행 시간을 가진 작업을 스케줄 함
  ```
  예시: 작업 시간이 100초인 A가 0초에 도착하고 작업 시간이 10초인 B, C가 10초에 도착
  - A는 0초에 도착해서 10초까지 작업 후 중지
  - B는 10초에 도착, 20초에 작업 완료 -> 반환 시간은 20 - 10 = 10
  - C는 10초에 도착, 30초에 작업 완료 -> 반환 시간은 30 - 10 = 20
  - A가 30초부터 다시 작업 시작, 120초에 작업 완료 -> 반환 시간은 120 - 0 = 120
  => 세 작업의 평균 반환 시간은 (120 + 10 + 20) / 3 = 50
  ```
- 현재까지의 가정에서는 가장 최적의 알고리즘
- 새로운 평가 기준인 응답 시간을 함께 고려하면 최적의 알고리즘이라 하기 어려움
  - 응답 시간은 작업이 도착한 시간과 처음 스케줄 되는 시간의 차를 말함
  - 응답 시간 기준으로는 SJF가 좋은 알고리즘이 아니므로 이를 바탕으로 하는 STCF도 좋다고 할 수 없음

## 라운드 로빈(Round-Robin, RR)

- 작업이 끝날 때까지 기다리지 않고 일정 시간마다 작업을 변경하는 방식
- 이때 작업이 실행되는 일정 시간을 타임 슬라이스(time slice) 또는 스케줄링 퀀텀(scheduling quantum)이라 함
  - 타임 슬라이스의 길이는 타이머 인터럽트 주기의 배수여야 함  
    ex) 타이머 인터럽트의 주기가 10 ms라면 슬라이스의 길이는 10, 20, ...
  - 기본적으로 타임 슬라이스가 짧을수록 RR의 응답 성능이 좋아짐
  - 단, 너무 짧게 설정할 경우 문맥 교환 비용이 전체 성능에 큰 영향을 미치게 됨
- 이처럼 시간을 쪼개서 사용하기 때문에 타임 슬라이싱 방식이라고도 부름
- SJF와 RR를 비교하기 위한 예
  ```
  예시: 작업 시간이 5초인 A, B, C가 동시에 도착
  - SFJ
    - A는 0초에 도착해서 0초에 작업 시작, 5초에 작업 완료
      -> 응답 시간은 0 - 0 = 0, 반환 시간은 5 - 0 = 5
    - B는 0초에 도착해서 5초에 작업 시작, 10초에 작업 완료
      -> 응답 시간은 5 - 0 = 5, 반환 시간은 10 - 0 = 10
    - C는 0초에 도착해서 10초에 작업 시작, 15초에 작업 완료
      -> 응답 시간은 10 - 0 = 10, 반환 시간은 15 - 0 = 15
    => 세 작업의 평균 응답 시간은 (0 + 5 + 10) / 3 = 5, 평균 반환 시간은 (5 + 10 + 15) / 3 = 10
  - RR(타입 슬라이스는 1초)
    - A는 0초에 도착해서 0초에 작업 시작, 13초에 작업 완료
      -> 응답 시간은 0 - 0 = 0, 반환 시간은 13 - 0 = 13
    - B는 0초에 도착해서 1초에 작업 시작, 14초에 작업 완료
      -> 응답 시간은 1 - 0 = 1, 반환 시간은 14 - 0 = 14
    - C는 0초에 도착해서 2초에 작업 시작, 15초에 작업 완료
      -> 응답 시간은 2 - 0 = 2, 반환 시간은 15 - 0 = 15
    => 세 작업의 평균 응답 시간은 (0 + 1 + 2) / 3 = 1, 평균 반환 시간은 (13 + 14 + 15) / 3 = 14
  ```
  - RR이 응답 시간으로는 성능이 좋지만 반환 시간을 기준으로는 최악의 성능을 보이는 것을 알 수 있음
- 일반적으로 RR과 같은 공정한 정책은 응답 시간을 기준으로는 성능이 좋지만 반환 시간을 기준으로는 성능이 떨어짐
- 어떤 평가 기준을 더 중요하게 다룰지에 따라 적절한 알고리즘을 선택해야 함

## 입출력 연산의 고려

- 입출력 작업을 진행중일 때는 CPU를 사용하지 않음
- 즉, 어떤 프로세스가 입출력 작업을 수행하는 동안 운영체제는 다른 프로세스에게 CPU를 할당할 수 있음
  ```
  예시: 작업 시간이 5초인 A, B가 동시에 도착하고 A는 1초마다 1초의 입출력 시간이 필요
  - A가 0초부터 1초까지 CPU 작업을 수행하고 입출력 작업으로 넘어감
  - A가 1초부터 2초까지 입출력 작업을 수행하는 동안 B가 CPU 작업을 수행
  - A가 2초에 입출력 작업을 마치고 CPU 작업으로 돌아옴
  - A가 2초부터 3초까지 CPU 작업을 수행하고 입출력 작업으로 넘어감
  ...
  ```
  - 이렇게 입출력 작업이 진행되는 동안 다른 프로세스를 실행하면 자원을 효율적으로 활용할 수 있음

# 요약

- 두 가지 평가 기준인 반환 시간과 응답 시간 기준으로 여러 알고리즘을 분석해봄
- 한쪽 성능을 올리면 다른 성능이 내려가는 것을 알 수 있음
- 입출력이 필요한 경우에 어떤 식으로 자원을 효율적으로 활용하는지도 학습함
- 그러나 각 작업의 실행 시간을 알고 있다는 가정은 사실상 실현 불가능하기 때문에 각 알고리즘을 실제로 적용시킬 때 문제가 생김
- 가까운 과거를 통해 미래를 예측하는 스케줄러가 존재
- 이를 멀티 레벨 피드백 큐(multi-level feedback queue)라 하고 다음 장에서 학습할 예정
