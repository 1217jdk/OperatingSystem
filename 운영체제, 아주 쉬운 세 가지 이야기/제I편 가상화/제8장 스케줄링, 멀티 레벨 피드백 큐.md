# 개요

- 앞서 배운 내용들을 바탕으로 해결하고 싶은 문제는 두 가지
  - 짧은 작업을 먼저 처리해서 반환 시간을 최적화하고 싶음  
    하지만 지금까지와는 다르게 작업의 실행 시간을 알 수 없음
  - RR 알고리즘처럼 응답 시간을 최적화하고 싶음  
    RR 알고리즘은 반환 시간이 최악이라는 문제가 있음

# MLFQ의 동작 규칙

## 기본 규칙

- 각각 다른 우선순위가 배정된 여러 개의 큐로 구성됨
- 실행 준비가 된 프로세스는 이 중 하나의 큐에 존재
- 같은 큐에 있는 프로세스끼리는 같은 우선순위를 가지고 RR 방식으로 동작
- 각 작업의 우선순위는 동적으로 부여됨  
  ex) 어떤 작업이 반복적으로 입출력을 위해 CPU를 양보한다면 이 작업의 우선순위는 높게 부여  
  반대로 CPU를 집중적으로 사용하는 작업은 우선순위를 낮게 부여
- 작업이 진행되는 동안 해당 작업의 정보를 얻고 이 정보를 이용하여 미래 행동을 예측
- MLFQ는 두 가지 기본 규칙을 가지고 있음
  - 규칙 1. Priority(A) > Priority(B)이면, A가 실행됨
  - 규칙 2. Priority(B) = Priority(B)이면, RR 방식으로 실행됨

## 우선순위의 변경

- MLFQ가 작업의 우선순위를 어떻게 바꿀 것인지 결정해야 함
- 일반적인 워크로드에서는 다음 두 종류의 작업이 혼재되어 있음
  - 짧은 실행 시간을 갖고 CPU를 자주 양보하는 대화형 작업
  - 많은 CPU 시간을 요구하지만 응답 시간은 중요하지 않은 CPU 위주 작업
- 우선순위 변경을 위해 다음과 같은 규칙을 추가
  규칙 3. 작업이 시스템에 진입하면 가장 높은 우선순위, 즉 맨 위의 큐에 놓임
  규칙 4a. 주어진 타임 슬라이스를 모두 사용하면 작업의 우선순위가 낮아짐, 즉 한 단계 아래 큐로 이동
  규칙 4b. 타임 슬라이스를 소진하기 전에 CPU를 양도하면 같은 우선순위를 유지
- 위 규칙을 간단히 정리하면, 새로 들어온 작업이 짧은 작업이라 가정하고 짧다면 일찍 종료되고, 길다면 우선순위가 자연스럽게 내려가도록 하는 것
- 그러나 이 MLFQ에는 몇 가지 문제점이 존재
  1. 기아 상태가 발생할 수 있음
     - 시스템에 너무 많은 대화형 작업이 존재하면 대화형 작업으로 모든 CPU 시간을 소모하게 됨
     - 긴 작업 시간을 가지는 작업들은 시간을 할당받지 못하게 됨
  2. 악의적으로 CPU 시간을 독점할 수 있음
     - 현재 방식은 타임 슬라이스가 끝나기 전에 CPU를 양보하면 우선순위가 유지됨
     - 타임 슬라이스의 99%를 실행하고 CPU를 양도한다면 CPU를 거의 독점할 수 있음
  3. 프로그램의 특성이 시간이 지나서 바뀌어도 우선순위가 변하지 않음
     - 긴 작업 시간을 가지는 작업이 나중에 대화형 작업으로 바뀌게 되더라도 우선순위가 낮은 상태로 남아있음

## 우선순위의 상향 조정

- 주기적으로 모든 작업의 우선순위를 상향 조정한다면 1, 3번 문제를 해결 가능
- 이 내용을 규칙으로 만들면 다음과 같음
  - 규칙 5. 일정 기간 S가 지나면, 시스템의 모든 작업을 최상위 큐로 이동시킴
- 이때 S의 값을 설정하는 것이 중요한데, S가 너무 크면 기아 상태를 해결할 수 없고 너무 작으면 대화형 작업이 적절한 양의 CPU 시간을 사용할 수 없음
  - 이런 종류의 상수를 부두 상수라 부름

## 시간 측정 개선

- 2번 문제를 해결하기 위해 시간을 측정하는 방식을 개선할 필요가 있음
- 작업이 해당 큐에서 사용한 총 시간을 측정하는 방식으로 변경
- 총 시간이 타임 슬라이스에 해당하는 시간을 초과하면 우선순위가 낮아짐
- 이 내용과 규칙 4a, 4b를 다음 규칙으로 통합
  - 규칙 4. 배정된 큐에서 시간 할당량을 소진하면 우선순위가 낮아짐

# MLFQ 조정과 다른 쟁점들

- 아직 MLFQ가 필요로 하는 변수들을 어떻게 설정하는지에 대한 문제가 남아있음  
  ex) 큐의 개수, 각 큐의 타임 슬라이스 크기, 우선순쉬 상향 조정 주기 등
- Solaris의 MLFQ는 관련 설정 테이블을 제공해서 이런 설정을 하기 편하게 만들어줌
- FreeBSD의 MLFQ는 우선순위 조정에 수학 공식을 적용시켜서 위의 설명과는 다른 감쇠-사용(decay-usage) 알고리즘을 적용시킴
- 대부분의 MLFQ는 운영체제가 높은 우선순위를 가질 수 있도록 일반 사용자의 작업이 가장 높은 우선순위를 가질 수 없게 함
- 사용자가 직접 우선순위를 조정할 수 있도록 제공하는 MLFQ도 있음  
  ex) nice 명령어

# 요약

- 앞서 배웠던 알고리즘들은 반환 시간이나 응답 시간을 평가 요소로 사용할 때 몇몇 문제가 있었음
- 이 문제들을 적절하게 해결할 수 있는 멀티 레벨 피드백 큐 스케줄링이 존재
- 5가지 규칙에 따라 우선순위를 조정하고 작업을 수행
