# 개요

- 운영체제는 CPU를 가상화하기 위해 여러 작업들이 동시에 실행되는 것처럼 보이는 것처럼 물리적인 CPU를 공유함
- 기본적인 아이디어는 각 프로세스를 잠깐 실행하고 멈추는 것을 반복하는 방식으로 CPU의 시간을 나누어 쓰는 것
- 이런 기법을 구현할 때 다음 문제들을 해결해야 함
  - 성능 저하: 시스템에 과중한 오버헤드를 주지 않아야 함
  - 제어 문제: CPU에 대한 통제를 유지하면서 프로세스를 효율적으로 실행해야 함
    - 특히 운영체제가 제어권을 상실할 경우 한 프로세스가 영원히 컴퓨터를 장악하기 때문에 가장 중요함

# 기본 원리: 제한적 직접 실행

- 프로그램을 빠르게 실행하기 위해 제한적 직접 실행(Limited Direct Execution)이라는 방식이 개발됨
- 이때 직접 실행이라는 것은 지금까지 배웠던 것 처럼(프로세스 생성, 메모리 할당 등) 프로세스를 실행하는 것을 말함
- 지금까지 처럼 직접 실행을 할 경우 다음 문제들이 생길 수 있음
  - 프로그램이 운영체제가 원치 않는 일을 하지 않는다는 것을 어떻게 보장할 수 있는가?
  - 운영체제가 어떻게 프로그램의 실행을 중단하고 다른 프로세스로 전환할 수 있는가?

## 문제점1: 제한된 연산

### 모드의 분할

- 프로세스에서 디스크 입출력이나 추가 자원 할당과 같은 요청을 할 수 있음
- 이런 요청을 프로세스가 원하는대로 하도록 방치하면 접근 권한을 제한하는 시스템이 의미가 없어질 것
- 보통 사용자 모드(user mode)와 커널 모드(kernel mode)를 구분하는 것으로 이 문제를 해결
  - 사용자 모드(user mode): 특수한 명령어들을 직접 사용할 수 없도록 제한된 상태
  - 커널 모드(kernel mode): 사용자 모드에서 제한된 명령어를 사용할 수 있는 상태
- 그러나 이렇게 설정된 경우 사용자 모드에서 특수한 명령어들을 실행할 필요가 있을 때 사용할 수 없음

### trap 명령어

- 운영체제는 trap이라는 명령어를 제공해서 사용자 모드에서도 시스템 콜을 호출할 수 있도록 함
- trap 명령어를 사용할 경우 다음과 같은 동작을 수행
  - 커널 안으로 분기하면서 특권 수준이 커널 수준으로 향샹됨
  - 기존 프로세스로 돌아갈 수 있도록 프로세스의 중요한 레지스터들을 각 프로세스의 커널 스택에 저장
- 작업이 완료되면 운영체제는 return-from-trap 명령어를 실행해서 기존 프로세스로 돌아가고 특권 수준을 다시 하향 조정함

### 트랩 테이블

- 위의 내용만으로는 trap 명령어 실행 시 운영체제 코드의 어느 주소를 실행하면 되는지 알 수 없음
  - 주소를 직접 명시하도록 할 경우 커널 내부에 원하는 지점에 접근할 수 있어지므로 위험함
- 커널은 부팅될 때 트랩 테이블을 만들고 이를 바탕으로 시스템을 통제
  - 트랩 테이블에는 시스템 콜이나 예외가 발생했을 때 어떤 코드를 실행해야하는지 저장되어 있음
  - 운영체제는 특수한 명령어로 이런 트랩 핸들러의 위치를 하드웨어에게 알려줄 수 있음
  - 그래서 하드웨어는 각 상황에 맞는 동작을 할 수 있음

## 문제점2: 프로세스 간 전환

- CPU에서 프로세스가 실행 중이라는 것은 운영체제가 실행 중이 아니라는 것을 의미
  - 이런 상황에서는 운영체제가 프로세스에 어떤 조치도 취할 수 없음
- 운영체제는 이런 상황에 CPU를 다시 획득할 수 있는 방법이 있어야 함

### 협조 방식: 시스템 콜 기다리기

- 프로세스들이 주기적으로 CPU를 포기할 것이라는 전제가 담긴 방식
- 협조(cooperative) 방식으로 알려진 이 방법은 과거에 몇몇 운영체제에서 사용됐음
- 실제로 대부분의 프로세스들은 다양한 시스템 콜을 사용하기 때문에 CPU를 운영체제에게 넘기고 있음
- 이 외에도 응용 프로그램이 비정상적인 행위를 할 경우 운영체제에게 제어가 넘어옴
- 운영체제는 이럴 때 다른 프로세스를 실행하거나 비정상적인 행위를 한 프로세스를 종료시킬 수 있음
- 그러나 어떠한 이유로 프로세스가 무한 루프에 빠질 경우 운영체제가 대처할 방법이 없음

### 비협조 방식: 운영체제가 전권을 행사

- 타이머 인터럽트(timer interrupt)를 통해 일정 시간마다 강제로 프로세스를 종료시키는 것으로 CPU 제어권을 얻을 수 있음
- 운영체제는 부팅할 때 이를 위한 준비를 함
  - 타이머 시작
  - 타이머 인터럽트가 발생했을 때 실행할 코드를 트랩 테이블에 작성
- 하드웨어도 타이머 인터럽트 발생 시 다시 프로세스로 돌아갈 수 있도록 프로세스의 정보를 커널 스택에 저장

### 문맥의 저장과 복원

- 협조 또는 비협조 방식으로 권한을 얻은 운영체제는 스커줄러를 통해 다른 프로세스로 전환할지 결정함
- 전환하기로 결정되면 문맥 교환(context switch)이라 알려진 코드를 실행
  - 문맥 교환은 앞서 얘기했던 프로세스 정보를 커널 스택에 저장하거나 이를 복원하는 것을 말함
  - 전환하려는 프로세스의 커널 스택으로 교체하는 작업도 포함됨
- 문맥 교환 작업은 저수준의 어셈블리어로 구현되어 있음

## 병행성 문제

- 만약 시스템 콜이나 인터럽트에 대한 처리 도중 다른 시스템 콜이나 인터럽트가 발생하면 문제가 생길 것
- 이는 병행성에 관한 문제이고 뒤에서 자세히 다룰 것
- 간단히 얘기하자면 인터럽트 불가능 상태로 만들거나 락(lock)을 설정하는 등의 방식을 사용

# 요약

- 기본적으로는 프로그램을 기존처럼 직접 실행
- 하지만 프로그램의 권한을 제한하거나 운영체제가 CPU 권한을 가져오도록 설정하는 방식으로 프로세스의 작업을 제한
- 이런 식으로 CPU 가상화를 위해 사용하는 저수준 기법들을 묶어서 제한적 직접 실행이라 함
- 앞으로 언제 어떤 프로세스를 실행해야 하는지 결정하기 위한 스케줄러에 대해 학습할 것
